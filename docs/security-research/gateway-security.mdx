---
title: "Gateway Security Architecture"
description: "Secure ingress/egress with automated certificate management in dstack"
---

# Gateway Security Architecture

<Callout type="info" icon="shield">
**Component**: `dstack-gateway` | [View Source](https://github.com/Dstack-TEE/dstack/tree/master/gateway)
</Callout>

## Overview

The dstack-gateway operates as the core security perimeter for all external and internal communications within the infrastructure. Its responsibilities encompass terminating Transport Layer Security (TLS) connections with certificates attested by Trusted Execution Environments (TEE), managing certificate lifecycle in a fully automated fashion via Let's Encrypt, routing requests while enforcing enclave attestation verification, and providing robust mitigation against denial-of-service (DDoS) attacks through rate-limiting mechanisms.

## Security Model

### Trust Architecture

```mermaid
graph TD
    subgraph "External"
        U[User/Client]
        CA[Let's Encrypt CA]
    end
    
    subgraph "Gateway TEE"
        G[dstack-gateway]
        CB[certbot]
        KMS[KMS Integration]
    end
    
    subgraph "Backend TEEs"
        A1[App CVM 1]
        A2[App CVM 2]
    end
    
    U -->|TLS| G
    CA -->|ACME| CB
    CB -->|Cert Storage| KMS
    G -->|mTLS| A1
    G -->|mTLS| A2
````

### Key Security Properties

The architecture ensures that TLS private keys are strictly generated and managed within a hardware-backed enclave, never leaving the confines of the TEE and always protected by hardware sealing mechanisms. Each certificate is cryptographically bound to a specific enclave measurement via attestation, guaranteeing both the authenticity of the key and the environment in which it operates. All certificates are logged to Certificate Transparency (CT) logs, allowing for independent monitoring and real-time detection of rogue or mis-issued certificates. DNS Certification Authority Authorization (CAA) records are leveraged to restrict the issuance to specific trusted authorities, while zero-trust networking is implemented by requiring mutual attestation for every connection, thus ensuring no plaintext or unauthenticated traffic traverses the internal or external boundaries.

## Implementation Details

### Certificate Management Flow

The certificate lifecycle begins inside the TEE, where a dedicated process generates a fresh asymmetric key pair. At no point does the private key exit the enclave, thereby leveraging the underlying hardware's confidentiality guarantees from inception. The process continues with the assembly of a certificate signing request (CSR) that embeds a TEE attestation quote as a custom extension, thereby binding every issued certificate to a measured and verifiable enclave state. An ACME client, operating within the TEE, negotiates the certificate issuance with Let's Encrypt, utilizing DNS-01 challenges to assert domain ownership. This is accomplished without exposing any challenge tokens in plaintext to the broader environment; all sensitive operations remain sealed in memory. After successful issuance, the certificate and its sealed private key are persisted only to a key management service (KMS) capable of releasing them exclusively to hosts presenting a matching enclave attestation, thereby preventing key extraction or misuse outside of authorized TEEs.

### Request Routing Security

When a client initiates a request, the gateway immediately extracts and verifies the client's certificate, focusing on the embedded TEE attestation data. Certificates that lack a valid signature or exhibit stale measurements are rejected outright. Upon successful validation, the gateway compares the runtime measurements of the requestor with its pool of available backend enclaves, selecting only those whose measurements satisfy policy constraints, thus ensuring symmetric trust between client and backend. The connection is then completed using mutual TLS, meaning all communication is cryptographically protected and authenticated end-to-end, with attestation forming the root of trust for all parties.

## Threat Mitigation

### Attack Surface Analysis

The system's security model is built upon strict mitigation strategies for all major attack vectors. For volumetric DDoS threats, the gateway employs a combination of rate-limiting and CDN-based traffic filtering, using a per-IP token bucket algorithm to enforce quotas. Protocol downgrade attacks are prevented by enforcing TLS 1.3 exclusively, with a tightly controlled cipher suite policy that disallows legacy algorithms. Certificate hijacking attempts are rapidly detected through continuous monitoring of certificate transparency logs, triggering real-time alerts for unauthorized issuance. DNS poisoning is addressed by validating all DNS responses with DNSSEC, using recursive resolution to verify cryptographic signatures. HTTP request smuggling is rendered ineffective by adhering strictly to HTTP/2 and enforcing robust input parsing and canonicalization at every layer.

### Security Headers

All HTTP responses generated by the gateway are supplemented with security-centric HTTP headers. The Strict-Transport-Security (HSTS) header instructs browsers to enforce encrypted connections for at least a full year and to preload the policy for immediate application. Additional headers prevent MIME type sniffing (X-Content-Type-Options), mitigate clickjacking risks (X-Frame-Options), activate cross-site scripting filters (X-XSS-Protection), and restrict resource loading (Content-Security-Policy) to the service’s primary origin. The Referrer-Policy is set to limit cross-origin referrer leakage. These measures combine to significantly reduce the attack surface against client-side and network-based exploits.

## Certificate Security

### ACME Integration

The gateway’s ACME client is fully integrated with Let's Encrypt, automating the entire DNS-01 challenge process. For every new certificate request, the system generates a cryptographic TXT record based on the challenge token and updates the authoritative DNS provider through secure APIs. The process then monitors DNS propagation, ensuring that the record is visible to external resolvers before notifying Let's Encrypt for verification. All sensitive operations and secrets associated with this process are executed within the enclave, ensuring tokens and private data remain transient, sealed, and never accessible outside the TEE boundary. After validation, a new certificate is issued and securely provisioned into enclave-backed key storage.

The system extends every issued certificate with a custom X.509 extension containing the TEE’s attestation quote. This mechanism binds each certificate to a specific enclave state, making it independently verifiable by any third party and effectively coupling cryptographic authentication with hardware-backed attestation.

### Private Key Security

The secure key storage solution is architected around the principles of enclave-based sealing and hardware-rooted access control. Each domain’s private key is generated and sealed to an enclave’s measurement, and only the same or equivalently attested enclave instance can unseal and use the key for TLS operations. During live operation, an in-memory cache (residing in protected enclave memory) enables rapid access for handshake requests, but keys are never persisted or swapped into unprotected space. If a key is not available in cache, it is unsealed after confirming the enclave’s measurement matches that of the original sealing operation, thereby ensuring the confidentiality and integrity of private key material at all times and minimizing exposure to potential side-channel or speculative-execution attacks.

## Performance & Scalability

### Load Balancing

The load-balancing component implements an adaptive least-connections algorithm that dynamically selects the backend instance with the smallest active connection count, thereby avoiding over-concentration of long-lived or slow connections on any individual backend. Backend health is actively monitored via periodic probes at five-second intervals, and any backend that fails three consecutive checks is automatically withdrawn from the pool. Upon restoration of positive health probes, the backend is returned to service without operator intervention. Both system-wide and per-client connection quotas are enforced to defend against resource exhaustion attacks. Burstable loads are managed through a token-bucket rate-limiting algorithm that smooths traffic spikes without penalizing compliant clients or causing unnecessary disruptions to service.

### Caching Strategy

To maximize responsiveness and minimize backend load, the system integrates content distribution networks (CDNs) for static resources, leveraging global edge caching. Dynamic application content is cached in an encrypted Redis instance, ensuring that sensitive data remains protected while enabling rapid retrieval. Certificate data is cached with a 24-hour time-to-live, balancing security with operational efficiency by limiting the exposure window for revoked or compromised keys. Session affinity for stateful clients is maintained via consistent hashing, ensuring that subsequent requests from a given client are routed to the same backend instance when necessary.

## Monitoring & Alerting

### Security Events

The monitoring subsystem continuously aggregates and classifies runtime telemetry from all gateway operations. Security events are typed according to severity and nature: for instance, any attestation failure is escalated immediately and results in an immutable audit log entry, as well as real-time notification to operational security personnel. Imminent certificate expiry triggers preemptive renewal routines at least seven days prior to expiration, thus avoiding service interruptions. While isolated rate-limit violations are treated as low-severity events, repeated or volumetric spikes are further analyzed for DDoS signatures and, when appropriate, result in dynamic throttling or temporary blocking of the originating subnet.

## Best Practices

<Tabs>
  <Tab title="Deployment">
    In production environments, the gateway should always be deployed within a TEE instance that is isolated from application backends, minimizing the impact of compromise and ensuring compartmentalization. Geo-distributed DNS load balancing (GeoDNS) is recommended to optimize global performance and provide resilience against regional failures. Circuit breakers must be implemented at the application and transport layer to automatically detect and contain backend faults, preventing cascading failures. Regular rotation of all TLS certificates is required, with a maximum lifetime not exceeding 90 days, to ensure cryptographic agility and reduce the risk of key compromise.
  </Tab>
  <Tab title="Configuration">
    Production deployments require TLS 1.3 as the sole permitted protocol, with allowed cipher suites restricted to state-of-the-art, authenticated encryption (AES-256-GCM and ChaCha20-Poly1305). HTTP Strict Transport Security and Certificate Transparency logging must be active for all domains. Server Name Indication is required for all connections to ensure endpoint-specific authentication. Rate limiting should be configured using a rolling one-minute window, with a maximum of one hundred requests permitted per client within each window, balancing security and service availability.
  </Tab>
</Tabs>

## Integration Testing

### Security Test Suite

Automated integration tests are used to validate every critical aspect of the gateway’s security posture. After each build, a full TLS configuration audit is performed using industry-standard tools such as `testssl.sh`, ensuring correct protocol negotiation, cipher suite enforcement, and certificate chain validity. Response headers are checked to confirm the presence and correct configuration of all required security policies, including HSTS, Content Security Policy, and X-Frame-Options. The attestation workflow is validated end-to-end by simulating certificate chains and verifying that attestation data is preserved and cryptographically valid at every layer. High-concurrency load and stress tests are conducted using tools that authenticate via client certificates, simulating realistic user and attack scenarios to empirically verify that rate limiting, backend failover, and DDoS mitigation logic operate as intended under real-world conditions.

## References

* [Let's Encrypt ACME Protocol](https://letsencrypt.org/docs/acme-protocol-updates/)
* [Certificate Transparency RFC 6962](https://datatracker.ietf.org/doc/html/rfc6962)
* [dstack Gateway Design](https://github.com/Dstack-TEE/dstack/tree/master/gateway)

```
