---
title: "KMS Security Architecture"
description: "Decentralized key management with hardware-backed security in dstack"
---

# KMS Security Architecture

**Component:** `dstack-kms` ([source](https://github.com/Dstack-TEE/dstack/tree/master/kms))

## Overview

dstack’s Key Management Service (KMS) implements decentralized, hardware-rooted key management. For a high-level architectural view, see the [dstack-kms README](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/kms/README.md).


## Architectural Synthesis

The dstack KMS represents a shift in key management design—moving from traditional, perimeter-based trust models to a composable, zero-trust architecture tailored for confidential computing. By fusing hardware attestation (Intel TDX), deterministic key derivation, and on-chain authorization, the KMS enforces not just secrecy, but *provable correctness* of both key issuance and key usage. Each cryptographic operation is tightly bound to attested hardware state and explicit authorization logic on decentralized smart contracts, eliminating the risks inherent in centralized storage and static access control lists.

Instead of relying on static secrets or vault-like key storage, all application and workload keys are derived on-demand from real-time attestation evidence. The system ensures every step—CVM provisioning, measurement validation, root-of-trust creation, and policy enforcement—is independently verifiable and cryptographically auditable. This enables robust horizontal scaling, flexible workload upgrades, and fine-grained policy governance, all without sacrificing cryptographic assurance. The result is a KMS architecture that embodies both strong confidentiality and transparent, externally verifiable integrity for distributed cloud-native and confidential workloads.


## Why Decentralized Key Management?

### Centralization Risks

Traditional KMS solutions introduce single points of failure, both in storage and trust. A compromise of the central KMS or its database can expose all managed keys. By contrast, dstack derives all application keys on demand, directly from hardware attestation data, eliminating the risk of key theft via database or infrastructure compromise.

### dstack’s Approach

```mermaid
graph LR
    subgraph "Traditional KMS"
        C[Central KMS]
        C --> K1[Key 1]
        C --> K2[Key 2]
        C --> K3[Key 3]
    end
    
    subgraph "dstack KMS"
        A1[Attestation 1] --> D1[Derived Key 1]
        A2[Attestation 2] --> D2[Derived Key 2]
        A3[Attestation 3] --> D3[Derived Key 3]
    end
````

dstack KMS supports three security modes—**non-kms (ephemeral keys), local-key-provider (SGX-sealed keys), and full kms mode (blockchain-authorized, upgradeable keys)**. Each mode is described in the [KMS README overview](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/kms/README.md#overview).

## Security Architecture

### Hardware-Backed Key Derivation

At the core of dstack KMS is a hardware-rooted key derivation model. Each key is produced via **HKDF-SHA256**, seeded by unique hardware attestation data—specifically, TDX measurements and a domain-separating salt ("RATLS") plus context data (such as application identifiers). See the key derivation implementation in [ra-tls/src/kdf.rs#L19](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/kdf.rs#L19).

Key derivation is hierarchical: parent keys can deterministically derive child keys for distinct application, instance, or usage contexts ([ra-tls/src/kdf.rs#L34](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/kdf.rs#L34)). This ensures every derived key is cryptographically unique and isolated—even if the same KMS instance manages thousands of workloads, each application’s secrets remain independently protected.

### Trust Model

dstack KMS’s security model is grounded in four main principles:

1. **Hardware Root of Trust**: All keys are derived from CPU and runtime measurements ([MRTD, RTMR0–RTMR3](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L393)).
2. **No Key Persistence**: Keys are regenerated as needed from attestation data and are never stored outside TEE memory.
3. **Attestation Gated Access**: Only workloads that have passed strict TDX quote and event log validation ([ra-tls/src/attestation.rs#L291](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L291)) can access keys.
4. **Determinism**: The same measurements and context will always yield the same derived key—supporting reproducibility and scalable, stateless key management.

## Implementation Details

### Cryptographic Key Hierarchy

The KMS manages a hierarchical key structure ([main\_service.rs#L50](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L50)), anchored by a root CA certificate and a k256 ECDSA key. The root CA signs X.509 certificates, while the k256 key enables Ethereum-compatible signing and encryption. Application-specific keys are derived on demand, incorporating the app ID, instance ID, and purpose string ([main\_service.rs#L498](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L498)), ensuring strong isolation between workloads and cryptographic roles.

### Secure Key Generation and Attestation

The process begins with attestation verification ([ra-tls/src/attestation.rs#L321](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L321)). Each key is only issued if the requester’s TDX quote is valid—meaning the signature, TCB status, and event logs all match expected measurements. If any aspect of attestation fails, key derivation is aborted.

After verification, dstack KMS deterministically derives keys for different functions—such as disk encryption, environment encryption, and signing ([main\_service.rs#L515](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L515)). Each key is bound to a unique cryptographic context and never reused outside its intended purpose.

## Security Properties

### Cryptographic Guarantees

* **Confidentiality:** Application secrets are encrypted using X25519 key exchange and ChaCha20-Poly1305 AEAD, with keys derived for each context ([main\_service.rs#L501](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L501)).
* **Integrity:** Keccak256 hashes and ECDSA signatures (k256) protect all authenticated messages and keys ([crypto.rs#L29](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/crypto.rs#L29)).
* **Authenticity:** ECDSA P-256 signatures provide cryptographic proof of origin ([crypto.rs#L7](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/crypto.rs#L7)).
* **Forward Secrecy:** All keys are derived fresh from attestation at each boot—there are no long-lived static secrets.
* **Reproducibility:** Identical environments will derive identical keys, supporting stateless scale-out and recovery.

### Attack Resistance

dstack KMS is designed for robust resistance to real-world attacks:

* **Key Extraction Prevention:** All keys exist only in TEE memory and are never written to disk in plaintext.
* **Replay Attack Mitigation:** Nonces and timestamps are included in attestation data ([attestation.rs#L47](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L47)), ensuring each attestation is unique and cannot be reused.
* **Rollback Protection:** Version checks in measurements ([attestation.rs#L345](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L345)) block attempts to use outdated or debug configurations.
* **Side Channel Hardening:** Cryptographic operations leverage constant-time code to reduce risk from timing attacks.

## Blockchain Integration

### Decentralized Authorization

dstack KMS integrates with Ethereum-compatible blockchains for decentralized authorization. The [AppAuth contract](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/auth-eth/contracts/AppAuth.sol#L9) enforces application-specific access controls—validating allowed compose hashes, device restrictions, and upgrade policies. The KmsAuth contract maintains registries for allowed KMS instances, OS images, and configurations, supporting transparent, auditable policy enforcement.

Authorization logic is enforced directly in the smart contract ([AppAuth.sol#L110](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/auth-eth/contracts/AppAuth.sol#L110)): application identity, compose hash, and device restrictions are all checked on-chain before key access is permitted. Owners can permanently disable upgrades for greater assurance.

### Attestation Verification Pipeline

Key provisioning is controlled by a strict attestation pipeline ([main\_service.rs#L407](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L407)), which verifies:

* TDX quote signature and measurement extraction
* Validation of all runtime measurements (MRTD, RTMR0–RTMR3), application metadata, and device IDs
* Integrity and authenticity of the VM configuration and OS image hash
* Aggregation of all attestation and config data into a `boot_info` structure
* Blockchain authorization via Auth smart contract
* Immediate denial and abort if any requirement fails

## Certificate Management and RA-TLS

### RA-TLS Implementation

dstack KMS implements **Remote Attestation TLS (RA-TLS)** by embedding TDX quotes, event logs, application IDs, and usage policy as custom X.509 extensions ([cert.rs#L227](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/cert.rs#L227)). Custom OIDs and DER encoding enable cryptographic validation of both certificate authenticity and the underlying TEE state.

Certificate signing requests include full attestation data, and only validated requests can obtain certificates ([ra-tls/src/cert.rs](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/ra-tls/src/cert.rs)). This guarantees that only fully attested workloads are eligible for trusted certificates.

### Custom OID Extensions

Special Object Identifiers (OIDs) embed security-critical data in X.509 certificates ([ra-tls/src/oids.rs](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/ra-tls/src/oids.rs)):

* Quote data: `1.3.6.1.4.1.62397.1.1`
* Event logs: `1.3.6.1.4.1.62397.1.2`
* Application IDs: `1.3.6.1.4.1.62397.1.3`
* Certificate usage: `1.3.6.1.4.1.62397.1.4`

These custom extensions allow any relying party to verify not only certificate validity, but also the full hardware-backed attestation state of the workload.

## Verification and Audit Procedures

### Security Auditing

Security auditors are encouraged to review the entire attestation and key derivation logic, including TDX quote validation, measurement whitelists, and event log replay ([attestation.rs#L422](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/ra-tls/src/attestation.rs#L422)). This ensures RTMR values genuinely reflect the execution path. Deterministic key derivation enables repeated audits and comparison of outputs with known inputs.

### Measurement Validation

Verification requires validation of five categories: MRTD (firmware), RTMR0 (hardware config), RTMR1 (kernel), RTMR2 (boot params), RTMR3 (application). The [attestation documentation](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/attestation.md#22-determining-expected-mrs) details expected values and verification steps. Building the OS image from source and using dstack-mr to calculate measurements allows independent validation.

## Performance and Scalability

### Cryptographic Performance

HKDF-SHA256 key derivation is highly efficient and incurs minimal computational overhead. dstack KMS is designed for concurrent, parallel key operations with no compromise to cryptographic guarantees.

### Distributed KMS Scaling

KMS supports secure self-replication, allowing new nodes to obtain root keys from attested peers using authenticated channels ([kms self-replication documentation](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/kms/README.md#kms-self-replication)). This supports horizontal scaling while maintaining attestation-based trust.

## Security Best Practices

### Key Usage

Applications should always request only the minimum required keys, enforce least privilege, and rotate keys as appropriate. Each derived key is purpose-scoped and must only be used for its intended cryptographic function.

### Attestation Policy Management

Organizations should maintain strict policies specifying allowed measurements, TCB versions, and configurations. Regular review and updates ensure the system remains robust as threats evolve.

### Monitoring and Auditing

dstack KMS logs all key derivation, attestation, and authorization events. Continuous monitoring for anomalous access or policy violations is strongly recommended.

## Integration and Application Security

### Application Integration

Applications must validate certificate chains and attestation evidence for every trust relationship ([KMS documentation: attestation](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/kms/README.md#attestation)). Signature chains must be checked from the message to the registered KMS root key.

### Network Security

All communications with the KMS occur over RA-TLS channels with mutual attestation, ensuring that only trusted endpoints exchange key material.

## Threat Model and Limitations

### Adversary Assumptions

The model assumes attackers may compromise hosts, networks, or infrastructure, but not the TEE hardware, attestation infrastructure, or correctly configured smart contracts.

### Security Boundaries

The system is engineered to prevent unauthorized key access, attestation forgery, and policy bypass, provided hardware and attestation are trusted and correctly configured.

## References and Further Reading

* [ra-tls key derivation](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/ra-tls/src/kdf.rs)
* [ra-tls attestation verification](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/ra-tls/src/attestation.rs)
* [ra-tls certificate management](https://github.com/Dstack-TEE/dstack/blob/45ebd05a/ra-tls/src/cert.rs)
* [KMS authorization policy](https://github.com/Dstack-TEE/dstack/blob/45ebd05a25ad4ffacce3b8f003e4f5a8b609b2e2/kms/src/main_service.rs#L407)
* [NIST SP 800-56C Rev. 2](https://csrc.nist.gov/publications/detail/sp/800-56c/rev-2/final)
* [dstack KMS Design](https://github.com/Dstack-TEE/dstack/blob/master/kms/DESIGN.md)
* [NIST Key Derivation Functions](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)

<div className="mt-8 p-4 bg-purple-50 rounded-lg border border-purple-200">
  <p className="text-sm text-purple-800">
    <strong>Next Component:</strong> See how derived keys protect traffic in the <a href="/docs/security-research/gateway-security" className="underline">Gateway security architecture</a>.
  </p>
</div>
