---
title: "Deploying Applications"
description: "Complete guide to deploying containerized applications to dstack"
---

# Deploying Applications to dstack

This comprehensive guide covers deploying containerized applications to dstack's Confidential Virtual Machine (CVM) environment using the real dstack architecture.

## Prerequisites

Before deploying applications, ensure you have:

- âœ… **TDX-capable hardware** with Intel TDX support [1](#0-0) 
- âœ… **dstack-vmm running** (Virtual Machine Manager) [2](#0-1) 
- âœ… **Guest OS images downloaded** (dstack OS images) [3](#0-2) 
- âœ… **KMS and Gateway deployed** (for production workloads) [4](#0-3) 

## Understanding dstack Application Architecture

### App-Compose Format

dstack uses a specialized **app-compose.json** format instead of direct docker-compose deployment. This format embeds your docker-compose.yaml content alongside dstack-specific configuration [5](#0-4) .

The app-compose.json structure includes:
- `manifest_version: 2` (current version)
- `docker_compose_file` (your docker-compose.yaml as embedded string)
- Security settings (KMS, gateway, encryption options)
- Environment variable allowlists
- Key provider configuration

### Virtual Machine Manager (VMM)

Applications deploy through **dstack-vmm**, which manages Confidential Virtual Machines [6](#0-5) . The VMM:
- Creates isolated CVMs for each application
- Handles encrypted environment variables
- Manages port mappings and resource allocation
- Provides attestation and security guarantees

## Step-by-Step Deployment Process

### Step 1: Prepare Your Docker Compose Application

Create your standard `docker-compose.yaml` file. This gets embedded into the app-compose.json format:

```yaml
# Example: docker-compose.yaml
version: '3.8'
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    environment:
      - NODE_ENV=production
```

### Step 2: Generate App-Compose Configuration

Use the **vmm-cli.py** tool to create your app-compose.json [7](#0-6) :

```bash
# Basic app-compose generation
python3 vmm-cli.py compose \
  --name myapp \
  --docker-compose docker-compose.yaml \
  --output .app-compose.json

# With advanced features
python3 vmm-cli.py compose \
  --name myapp \
  --docker-compose docker-compose.yaml \
  --kms \
  --gateway \
  --public-logs \
  --env-file .env \
  --output .app-compose.json
```

### Step 3: Deploy to dstack-vmm

Deploy your application using the generated app-compose.json [8](#0-7) :

```bash
# Basic deployment
python3 vmm-cli.py deploy \
  --name myapp \
  --compose .app-compose.json \
  --image dstack-0.5.1 \
  --port tcp:127.0.0.1:8080:8080 \
  --vcpu 2 \
  --memory 4G

# Production deployment with encryption
python3 vmm-cli.py deploy \
  --name myapp \
  --app-id your-registered-app-id \
  --compose .app-compose.json \
  --image dstack-0.5.1 \
  --env-file .env \
  --port tcp:0.0.0.0:8080:8080 \
  --vcpu 4 \
  --memory 8G \
  --kms-url https://your-kms-url:9201
```

## Production Deployment Requirements

### On-Chain Application Registration

For production deployments, applications must be registered on-chain through the KmsAuth contract system [9](#0-8) :

```bash
# Deploy AppAuth contract and register
cd kms/auth-eth
npm install
npx hardhat compile
export PRIVATE_KEY=your-private-key
npx hardhat app:deploy --allow-any-device --network phala
```

### Adding Compose Hash to Whitelist

The app-compose.json hash must be whitelisted in the AppAuth contract [10](#0-9) :

```bash
# Add your app's compose hash to whitelist
npx hardhat app:add-hash --network phala \
  --app-id your-app-id \
  your-compose-hash
```

## Environment Variable Encryption

dstack automatically encrypts environment variables for security [11](#0-10) . The process:

1. Retrieves encryption public key from KMS
2. Encrypts environment variables using X25519 + AES-GCM
3. Passes encrypted data to the CVM
4. CVM decrypts variables at runtime

## Real-World Deployment Examples

### KMS Deployment Example

The KMS component deployment demonstrates the complete process [12](#0-11) :

- Generates app-compose.json with local key provider
- Deploys with specific port mappings
- Uses environment file for configuration
- Includes resource specifications (8 vCPU, 8GB RAM)

### Gateway Deployment Example

The Gateway deployment shows advanced features [13](#0-12) :

- Uses pre-launch script for token validation
- Enables KMS integration
- Includes public logs and sysinfo
- Supports existing app-compose.json files via `-c` flag

## Management and Monitoring

### VM Lifecycle Management

Monitor and manage your deployed applications [14](#0-13) :

```bash
# List all VMs
python3 vmm-cli.py lsvm -v

# View application logs
python3 vmm-cli.py logs vm-id -f

# Start/stop VMs
python3 vmm-cli.py start vm-id
python3 vmm-cli.py stop vm-id

# Remove VM
python3 vmm-cli.py remove vm-id
```

### Environment Variable Updates

Update encrypted environment variables for running applications [15](#0-14) :

```bash
python3 vmm-cli.py update-env vm-id \
  --env-file updated.env \
  --kms-url https://your-kms-url:9201
```

## Application Execution Process

Inside the CVM, applications execute through the **app-compose.sh** script [16](#0-15) :

1. Extracts docker-compose.yaml from app-compose.json
2. Runs pre-launch script (if specified)
3. Starts Docker daemon and containers
4. Performs cleanup (image/volume pruning)

## Security and Attestation

### Trust and Verification

dstack includes signature verification for KMS public keys [17](#0-16) . The system:

- Verifies cryptographic signatures on encryption keys
- Maintains whitelist of trusted signers
- Provides attestation capabilities for deployed applications

### Resource Isolation

Each application runs in its own Confidential Virtual Machine with:
- Dedicated CPU and memory allocation
- Encrypted storage and communication
- Network isolation through port mappings
- Hardware-level security guarantees via Intel TDX

## Best Practices

### Security Configuration

- Always use encrypted environment variables for sensitive data
- Register applications on-chain for production deployments
- Verify KMS signatures and maintain trusted signer whitelists
- Use specific image tags, not `latest`

### Resource Management

- Specify appropriate CPU and memory limits
- Use health checks in your docker-compose.yaml
- Implement proper logging for debugging
- Plan for persistent storage needs

### Development Workflow

1. Develop and test with standard docker-compose locally
2. Generate app-compose.json for dstack deployment
3. Test deployment in development environment
4. Register application on-chain for production
5. Deploy to production dstack cluster

---

still confused on what to do?

- ðŸ‘‰ [Start with the installation guide](/docs/getting-started/install/installation)
- ðŸ‘‰ [Then follow the first deployment guide](/docs/getting-started/first-deployment-steps/first-deployment)
