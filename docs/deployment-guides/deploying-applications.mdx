---
title: "Deploying Applications"
description: "Complete guide to deploying containerized applications to dstack"
---

# Deploying Applications

This guide covers everything you need to know about deploying applications to dstack, from simple single-container apps to complex multi-service architectures.

## Prerequisites

Before deploying applications, ensure you have:

- ✅ dstack installed and running ([Installation Guide](/getting-started/installation))
- ✅ Docker installed locally for building images
- ✅ Access to dstack web UI or CLI
- ✅ Basic understanding of Docker and docker-compose

## Deployment Methods

dstack supports multiple deployment methods:

<CardGroup cols={3}>
  <Card title="Web UI" icon="browser">
    Visual deployment through dashboard
  </Card>
  <Card title="CLI" icon="terminal">
    Command-line deployment
  </Card>
  <Card title="API" icon="code">
    Programmatic deployment
  </Card>
</CardGroup>

## Preparing Your Application

### Step 1: Containerize Your Application

If your application isn't already containerized, create a Dockerfile:

```dockerfile
# Example Dockerfile for a Node.js app
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Run application
CMD ["node", "server.js"]
```

### Step 2: Create docker-compose.yml

dstack uses docker-compose format for deployments:

```yaml
version: '3.8'

services:
  web:
    build: .
    # Or use pre-built image
    # image: myregistry/myapp:latest
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=info
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    
  # Add more services as needed
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  redis_data:
```

### Step 3: Test Locally

Before deploying to dstack, test your application locally:

```bash
# Build and run locally
docker-compose up --build

# Test the application
curl http://localhost:8080

# Stop when done
docker-compose down
```

## Deployment Process

### Option 1: Deploy via Web UI

1. **Access Dashboard**
   - Navigate to http://localhost:9080
   - Log in with your credentials

2. **Create New Deployment**
   - Click "Deploy New Application"
   - Enter application details:
     - **Name**: unique identifier for your app
     - **Description**: optional description
     - **Compose File**: upload your docker-compose.yml

3. **Configure Resources**
   
   | Resource | Default | Production Recommended |
   |----------|---------|----------------------|
   | CPU | 2 cores | 4+ cores |
   | Memory | 4 GB | 8+ GB |
   | Storage | 10 GB | 50+ GB |
   | Network | NAT | Bridge mode |

4. **Advanced Settings** (optional)
   - **GPU**: Enable for ML workloads
   - **Persistent Storage**: For stateful applications
   - **Custom Domain**: Use your own domain

5. **Deploy**
   - Review configuration
   - Click "Deploy"
   - Monitor progress in real-time

### Option 2: Deploy via CLI

```bash
# Basic deployment
dstack deploy --name myapp --compose docker-compose.yml

# With custom resources
dstack deploy \
  --name myapp \
  --compose docker-compose.yml \
  --cpu 4 \
  --memory 8G \
  --storage 50G

# Deploy with environment file
dstack deploy \
  --name myapp \
  --compose docker-compose.yml \
  --env-file .env.production

# Deploy and wait for ready
dstack deploy \
  --name myapp \
  --compose docker-compose.yml \
  --wait \
  --timeout 300
```

### Option 3: Deploy via API

```python
import requests
import yaml

# Load compose file
with open('docker-compose.yml', 'r') as f:
    compose_content = yaml.safe_load(f)

# Deployment configuration
deployment = {
    "name": "myapp",
    "compose": compose_content,
    "resources": {
        "cpu": 4,
        "memory": "8G",
        "storage": "50G"
    },
    "environment": {
        "API_KEY": "secret-key",
        "DATABASE_URL": "postgresql://..."
    }
}

# Deploy via API
response = requests.post(
    'http://localhost:9080/api/v1/deployments',
    json=deployment,
    headers={'Authorization': 'Bearer YOUR_TOKEN'}
)

if response.status_code == 201:
    print(f"Deployment created: {response.json()['id']}")
```

## Multi-Service Applications

### Example: Web App with Database

```yaml
version: '3.8'

services:
  web:
    image: myapp:latest
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
      - REDIS_URL=redis://cache:6379
    depends_on:
      - db
      - cache
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - db_data:/var/lib/postgresql/data
    restart: unless-stopped

  cache:
    image: redis:7-alpine
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
    restart: unless-stopped

  # Background worker
  worker:
    image: myapp:latest
    command: python worker.py
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
      - REDIS_URL=redis://cache:6379
    depends_on:
      - db
      - cache
    restart: unless-stopped

volumes:
  db_data:
    driver: local
```

### Service Discovery

Services can communicate using their service names:

```python
# In your application code
import redis
import psycopg2

# Connect to Redis using service name
redis_client = redis.from_url('redis://cache:6379')

# Connect to PostgreSQL using service name
conn = psycopg2.connect('postgresql://postgres:password@db:5432/myapp')
```

## Environment Variables & Secrets

### Using Environment Variables

```yaml
services:
  app:
    image: myapp:latest
    environment:
      # Hardcoded values (not recommended for secrets)
      - NODE_ENV=production
      
      # From host environment
      - API_KEY=${API_KEY}
      
      # From .env file
      - DATABASE_URL=${DATABASE_URL}
```

### Managing Secrets Securely

1. **Create Secret in dstack**
   ```bash
   dstack secret create myapp-secrets \
     --from-literal=api_key=abc123 \
     --from-literal=db_password=secret
   ```

2. **Reference in Compose**
   ```yaml
   services:
     app:
       image: myapp:latest
       secrets:
         - myapp-secrets
       environment:
         - API_KEY=/run/secrets/api_key
   ```

## Persistent Storage

### Volume Configuration

```yaml
services:
  database:
    image: postgres:15
    volumes:
      # Named volume (recommended)
      - db_data:/var/lib/postgresql/data
      
      # Bind mount (for development)
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro

volumes:
  db_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/persistent/db
```

### Backup Strategy

```bash
# Backup volume data
dstack volume backup db_data --output backup.tar.gz

# Restore volume data
dstack volume restore db_data --input backup.tar.gz
```

## Health Checks & Monitoring

### Configuring Health Checks

```yaml
services:
  web:
    image: myapp:latest
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

### Custom Health Check Endpoint

```python
# Flask example
@app.route('/health')
def health_check():
    # Check dependencies
    checks = {
        'database': check_database(),
        'redis': check_redis(),
        'disk_space': check_disk_space()
    }
    
    # Return appropriate status
    if all(checks.values()):
        return jsonify({'status': 'healthy', 'checks': checks}), 200
    else:
        return jsonify({'status': 'unhealthy', 'checks': checks}), 503
```

## Scaling Applications

### Horizontal Scaling

```yaml
services:
  web:
    image: myapp:latest
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 2G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
```

### Auto-scaling Configuration

```bash
# Enable auto-scaling
dstack autoscale create myapp-web \
  --deployment myapp \
  --service web \
  --min 2 \
  --max 10 \
  --cpu-threshold 70 \
  --memory-threshold 80
```

## Zero-Downtime Deployments

### Blue-Green Deployment

```bash
# Deploy new version to green environment
dstack deploy --name myapp-green --compose docker-compose.yml

# Verify green deployment
dstack verify myapp-green

# Switch traffic to green
dstack switch myapp --to myapp-green

# Remove old blue deployment
dstack remove myapp-blue
```

### Rolling Updates

```yaml
services:
  web:
    image: myapp:v2
    deploy:
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        monitor: 30s
        max_failure_ratio: 0.3
```

## Post-Deployment

### Verify Deployment

```bash
# Check deployment status
dstack status myapp

# View application logs
dstack logs -f myapp

# Get application URL
dstack url myapp

# Verify attestation
dstack attest myapp
```

### Access Your Application

1. **Internal Access**
   ```bash
   # Get internal URL
   http://myapp.cvm.internal:8080
   ```

2. **External Access**
   ```bash
   # Default domain
   https://myapp.app.example.com
   
   # Custom domain (after configuration)
   https://api.mycompany.com
   ```

## Troubleshooting Deployments

### Common Issues

<details>
<summary>Deployment fails to start</summary>

1. Check logs:
   ```bash
   dstack logs myapp --tail 100
   ```

2. Verify image availability:
   ```bash
   docker pull myimage:tag
   ```

3. Check resource limits:
   ```bash
   dstack describe myapp
   ```

</details>

<details>
<summary>Application crashes repeatedly</summary>

1. Check health check configuration
2. Verify environment variables
3. Ensure dependencies are running
4. Check for port conflicts

</details>

<details>
<summary>Cannot access application</summary>

1. Verify deployment status:
   ```bash
   dstack status myapp
   ```

2. Check network configuration
3. Verify port mappings
4. Check gateway logs

</details>

## Best Practices

<div className="bg-blue-50 p-6 rounded-lg my-4">
  <h4 className="font-semibold mb-3">Deployment Checklist:</h4>
  <ul className="space-y-2">
    <li>☐ Use specific image tags (not `latest`)</li>
    <li>☐ Configure health checks</li>
    <li>☐ Set resource limits</li>
    <li>☐ Use secrets for sensitive data</li>
    <li>☐ Enable logging and monitoring</li>
    <li>☐ Test locally before deploying</li>
    <li>☐ Document environment variables</li>
    <li>☐ Plan for persistent storage</li>
    <li>☐ Configure restart policies</li>
    <li>☐ Set up backup procedures</li>
  </ul>
</div>

## Next Steps

<CardGroup cols={3}>
  <Card title="Configure Components" icon="cog" href="/deployment-guides/configuring-components">
    Fine-tune dstack components
  </Card>
  <Card title="Manage Secrets" icon="key" href="/deployment-guides/managing-keys-and-secrets">
    Secure key management
  </Card>
  <Card title="Monitor Apps" icon="chart-line" href="/deployment-guides/monitoring-and-logging">
    Set up monitoring
  </Card>
</CardGroup> 