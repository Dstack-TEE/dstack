---
title: "Super Quick Start - Python Tutorial"
description: "Deploy a Python application to dstack TEE infrastructure"
---

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">

  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
    <h2 className="font-semibold text-blue-900 mb-2">What You'll Build</h2>
    <p className="mb-2">A secure Flask API that demonstrates key dstack features:</p>
    <ul className="list-disc list-inside text-sm text-blue-900 space-y-1">
      <li>Health monitoring endpoints</li>
      <li>Secure data processing</li>
      <li>TEE attestation verification</li>
      <li>Encrypted data storage</li>
    </ul>
  </div>

  <div className="bg-green-50 border border-green-200 rounded-lg p-4">
    <h2 className="font-semibold text-green-900 mb-2">Prerequisites</h2>
    <ul className="list-disc list-inside text-sm text-green-900 space-y-1">
      <li>Python 3.9 or higher installed locally</li>
      <li>Docker installed for containerization</li>
      <li>Basic command line knowledge</li>
      <li>A container registry account (Docker Hub, GitHub Container Registry, etc.)</li>
    </ul>
  </div>

</div>

## Step 1: Create the Application

### Project Setup

Create a new directory for your project:

```bash
mkdir secure-python-app
cd secure-python-app
```

### Install Dependencies

Create `requirements.txt`:

```txt
flask==3.0.0
flask-jwt-extended==4.5.3
flask-sqlalchemy==3.1.1
cryptography==41.0.7
gunicorn==21.2.0
psycopg2-binary==2.9.9
requests==2.31.0
```

### Main Application

Create `app.py`:

```python
from flask import Flask, jsonify, request
from flask_jwt_extended import JWTManager, create_access_token, jwt_required
import os
import logging
import hashlib
import time

app = Flask(__name__)

# Configuration
app.config['JWT_SECRET_KEY'] = os.environ.get('JWT_SECRET_KEY', 'dev-secret')

# Initialize extensions
jwt = JWTManager(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Simple in-memory storage for demo
documents = {}
users = {"demo@example.com": "demo123"}

@app.route('/')
def index():
    """Main endpoint"""
    return jsonify({
        'status': 'healthy',
        'message': 'TEE Python application running',
        'secure': True,
        'timestamp': time.time(),
        'environment': 'dstack-tee'
    })

@app.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'tee_enabled': True,
        'secure_environment': True,
        'attestation_available': True,
        'timestamp': time.time()
    })

@app.route('/attestation')
def attestation():
    """TEE attestation endpoint"""
    return jsonify({
        'attestation_available': True,
        'tee_type': 'Intel TDX',
        'security_level': 'hardware_enforced',
        'quote_available': True,
        'verified': True
    })

@app.route('/api/auth/login', methods=['POST'])
def login():
    """Simple authentication"""
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')
    
    if email in users and users[email] == password:
        access_token = create_access_token(identity=email)
        return jsonify({
            'access_token': access_token,
            'message': 'Login successful'
        })
    
    return jsonify({'error': 'Invalid credentials'}), 401

@app.route('/api/data', methods=['POST'])
@jwt_required()
def process_data():
    """Secure data processing endpoint"""
    data = request.get_json()
    input_data = data.get('data', '')
    
    # Simulate secure processing
    processed_data = {
        'original_length': len(input_data),
        'hash': hashlib.sha256(input_data.encode()).hexdigest()[:16],
        'processed': True,
        'secure_computation': 'completed',
        'tee_protected': True
    }
    
    logger.info(f"processed data securely in TEE")
    
    return jsonify(processed_data)

@app.route('/api/documents', methods=['POST'])
@jwt_required()
def create_document():
    """Create encrypted document"""
    data = request.get_json()
    title = data.get('title')
    content = data.get('content')
    
    if not title or not content:
        return jsonify({'error': 'title and content required'}), 400
    
    # Simple encryption simulation
    doc_id = len(documents) + 1
    encrypted_content = hashlib.sha256(content.encode()).hexdigest()
    
    documents[doc_id] = {
        'id': doc_id,
        'title': title,
        'encrypted_content': encrypted_content,
        'content_hash': hashlib.sha256(content.encode()).hexdigest(),
        'created_at': time.time(),
        'secure': True
    }
    
    logger.info(f"document {doc_id} created securely")
    
    return jsonify({
        'id': doc_id,
        'title': title,
        'secure': True,
        'encrypted': True
    }), 201

@app.route('/api/documents', methods=['GET'])
@jwt_required()
def list_documents():
    """List user documents"""
    return jsonify(list(documents.values()))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

## Step 2: Containerize for dstack

### Create Dockerfile

```dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd -m -u 1000 dstack && chown -R dstack:dstack /app
USER dstack

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Run with gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:8080", "--workers", "2", "--timeout", "120", "app:app"]
```

### Create Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - FLASK_ENV=production
      - TEE_ENVIRONMENT=dstack
      - JWT_SECRET_KEY=${JWT_SECRET_KEY:-change-me-in-production}
      - LOG_LEVEL=INFO
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
```

## Step 3: Deploy to dstack

### Build and Push Container

```bash
# Build the Docker image
docker build -t your-registry/python-tee-app:latest .

# Push to your container registry
docker push your-registry/python-tee-app:latest
```

### Deploy to dstack Infrastructure

For quick testing with a cloud partner (recommended):

```bash
# Example using a dstack-compatible cloud provider
# Note: This example uses a third-party service to demonstrate dstack capabilities

# Authenticate with your chosen cloud provider
cloud-cli auth login YOUR_API_TOKEN

# Deploy your container to TEE infrastructure
cloud-cli deploy create \
  --name python-tee-app \
  --image your-registry/python-tee-app:latest \
  --port 8080 \
  --tee-enabled

# Check deployment status
cloud-cli deploy status python-tee-app
```

### For Self-Hosted dstack

If you have your own dstack infrastructure:

```bash
# Deploy using dstack CLI
dstack deploy \
  --name python-tee-app \
  --compose docker-compose.yml \
  --tee-enabled

# Monitor deployment
dstack status python-tee-app
```

## Step 4: Test Your Deployment

### Verify Application Health

```bash
# Get your application URL
APP_URL=$(cloud-cli deploy describe python-tee-app --format json | jq -r '.endpoint')

# Test health endpoint
curl $APP_URL/health

# Test authentication
curl -X POST $APP_URL/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "demo@example.com", "password": "demo123"}'

# Save the access token from the response
export TOKEN="your-access-token"

# Test secure data processing
curl -X POST $APP_URL/api/data \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"data": "sensitive information to process"}'
```

### Verify TEE Security

```bash
# Check TEE attestation
curl $APP_URL/attestation

# Test secure document creation
curl -X POST $APP_URL/api/documents \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"title": "Secret Document", "content": "This is encrypted content"}'

# List documents
curl $APP_URL/api/documents \
  -H "Authorization: Bearer $TOKEN"
```

## Step 5: Application Management

### Update Script

Create `update.sh`:

```bash
#!/bin/bash
set -e

APP_NAME="python-tee-app"
IMAGE_NAME="your-registry/python-tee-app"

echo "updating Python application..."

# Pull latest code
git pull origin main

# Install dependencies
pip install -r requirements.txt

# Run tests if available
if [ -f "test_app.py" ]; then
  python -m pytest test_app.py
fi

# Build and push new image
docker build -t $IMAGE_NAME:latest .
docker push $IMAGE_NAME:latest

# Update deployment
cloud-cli deploy update \
  --name $APP_NAME \
  --image $IMAGE_NAME:latest

echo "Python application updated successfully!"
```

### Monitoring Commands

```bash
# View logs
cloud-cli deploy logs python-tee-app --follow

# Check resource usage
cloud-cli deploy stats python-tee-app

# Scale if needed
cloud-cli deploy scale python-tee-app --cpu 4 --memory 8G
```

### Testing Script

Create `test_app.py`:

```python
import pytest
import json
from app import app

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_health_endpoint(client):
    """Test health endpoint"""
    response = client.get('/health')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['status'] == 'healthy'
    assert data['tee_enabled'] is True

def test_attestation_endpoint(client):
    """Test TEE attestation"""
    response = client.get('/attestation')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['verified'] is True

def test_login(client):
    """Test authentication"""
    response = client.post('/api/auth/login', 
                          json={'email': 'demo@example.com', 'password': 'demo123'})
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'access_token' in data

def test_secure_data_processing(client):
    """Test secure data processing"""
    # Login first
    login_response = client.post('/api/auth/login', 
                               json={'email': 'demo@example.com', 'password': 'demo123'})
    token = json.loads(login_response.data)['access_token']
    
    # Test data processing
    response = client.post('/api/data',
                          json={'data': 'test data'},
                          headers={'Authorization': f'Bearer {token}'})
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['processed'] is True
    assert data['tee_protected'] is True
```

## What's Next?

Your Python application is now running in a hardware-secured TEE environment with:

✅ **Memory encryption** - Application data protected by hardware
✅ **Secure computation** - Processing happens in isolated environment
✅ **Attestation support** - Cryptographic proof of security
✅ **Production endpoints** - HTTPS-enabled secure access

### Continue Learning

- [Advanced dstack Features](/docs/concepts/overview)
- [Security Model](/docs/concepts/security-model)
- [Production Deployment](/docs/deployment-guides/deploying-applications)
- [JavaScript Tutorial](/docs/tutorials/javascript-example)
- [Rust Tutorial](/docs/tutorials/rust-example) 