---
title: "Super Quick Start - Enterprise dstack Deployment Guide"
description: "Production-ready deployment patterns, CI/CD automation, and enterprise configurations for dstack"
---

<div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">

  <div className="bg-blue-50 border border-blue-200 rounded-lg p-6 flex flex-col justify-between">
    <div>
      <h2 className="font-semibold text-blue-900 mb-2 text-lg">üè¢ Enterprise dstack Deployment Guide</h2>
      <p className="text-sm text-blue-800 mb-4">
        This guide is for organizations deploying secure TEE workloads at scale. It assumes basic familiarity with dstack and focuses on production deployment for enterprise environments.
      </p>
      <ul className="list-disc list-inside text-blue-900 text-sm space-y-1 mb-2">
        <li>Enterprise deployment patterns for dstack</li>
        <li>CI/CD automation and monitoring</li>
        <li>Production-ready configurations</li>
        <li>Scaling and management strategies</li>
        <li>Security best practices</li>
      </ul>
    </div>
  </div>

  <div className="bg-green-50 border border-green-200 rounded-lg p-6 flex flex-col justify-between">
    <div>
      <h2 className="font-semibold text-green-900 mb-2 text-lg">üîë Prerequisites & Requirements</h2>
      <ul className="list-disc list-inside text-green-900 text-sm space-y-1 mb-2">
        <li>Experience with containerization and orchestration</li>
        <li>CI/CD pipeline knowledge (GitHub Actions, GitLab CI, or Jenkins)</li>
        <li>Infrastructure management experience</li>
        <li>Understanding of security best practices</li>
        <li>Monitoring and observability tools knowledge</li>
      </ul>
      <p className="text-xs text-green-700 mt-2">
        These skills ensure you can confidently deploy, scale, and secure dstack in production.
      </p>
    </div>
  </div>

</div>

### High Availability Setup

```yaml
# docker-compose.production.yml
version: '3.8'

services:
  app:
    image: your-registry/your-app:latest
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - TEE_ENVIRONMENT=dstack
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    networks:
      - dstack-network

  redis:
    image: redis:7-alpine
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G
    volumes:
      - redis_data:/data
    networks:
      - dstack-network

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G
    networks:
      - dstack-network

volumes:
  redis_data:
  postgres_data:

networks:
  dstack-network:
    driver: bridge
```

## ‚ö° Production-Ready Automation Scripts

### Complete CI/CD Integration Script

```bash
#!/bin/bash
# ci_cd_deploy.sh - Complete CI/CD Pipeline for dstack

set -e

# Configuration from environment variables
APP_NAME=${APP_NAME:-"enterprise-dstack-app"}
IMAGE_REGISTRY=${IMAGE_REGISTRY:-"your-registry.com"}
IMAGE_NAME="${IMAGE_REGISTRY}/${APP_NAME}"
DSTACK_TOKEN=${DSTACK_TOKEN}
ENVIRONMENT=${ENVIRONMENT:-"production"}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
  echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
  echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
  echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
  echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Validate environment
validate_environment() {
  log "validating environment..."
  
  if [ -z "$DSTACK_TOKEN" ]; then
    error "DSTACK_TOKEN environment variable is required"
    exit 1
  fi
  
  if ! command -v docker &> /dev/null; then
    error "docker is not installed"
    exit 1
  fi
  
  if ! command -v dstack &> /dev/null; then
    error "dstack CLI is not installed"
    exit 1
  fi
  
  success "environment validation passed"
}

# Security scanning
security_scan() {
  log "running security scans..."
  
  # Scan dependencies for vulnerabilities
  if [ -f "package.json" ]; then
    npm audit --audit-level=moderate
  elif [ -f "requirements.txt" ]; then
    pip install safety
    safety check
  elif [ -f "Cargo.toml" ]; then
    cargo audit
  fi
  
  # Scan Docker image for vulnerabilities
  if command -v trivy &> /dev/null; then
    trivy image "$IMAGE_NAME:latest"
  fi
  
  success "security scans completed"
}

# Build and test
build_and_test() {
  log "building application..."
  
  # Install dependencies based on project type
  if [ -f "package.json" ]; then
    npm ci --frozen-lockfile
    npm run build
    if grep -q "test" package.json; then
      npm test
    fi
    if grep -q "lint" package.json; then
      npm run lint
    fi
  elif [ -f "requirements.txt" ]; then
    pip install -r requirements.txt
    if [ -f "tests/" ] || [ -f "pytest.ini" ]; then
      python -m pytest --cov
    fi
  elif [ -f "Cargo.toml" ]; then
    cargo test
    cargo build --release
  fi
  
  success "build and tests completed"
}

# Docker operations
docker_build_and_push() {
  local tag="${1:-latest}"
  local full_image="${IMAGE_NAME}:${tag}"
  
  log "building Docker image: $full_image"
  
  # Build image with build arguments
  docker build \
    --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
    --build-arg VCS_REF=$(git rev-parse --short HEAD) \
    --build-arg VERSION=$tag \
    -t "$full_image" .
  
  # Build multi-platform and push
  docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
    --build-arg VCS_REF=$(git rev-parse --short HEAD) \
    --build-arg VERSION=$tag \
    -t "$full_image" \
    --push \
    --provenance=false .
  
  success "docker image built and pushed: $full_image"
}

# Deploy to dstack
deploy_to_dstack() {
  local app_name="$1"
  local image_tag="${2:-latest}"
  
  log "deploying $app_name to dstack..."
  
  # Authenticate
  dstack auth login "$DSTACK_TOKEN"
  
  # Update image in compose file
  sed -i "s|image: .*|image: ${IMAGE_NAME}:${image_tag}|g" docker-compose.production.yml
  
  # Check if deployment exists
  if dstack status "$app_name" &>/dev/null; then
    log "updating existing deployment: $app_name"
    dstack update --name "$app_name" --compose docker-compose.production.yml
  else
    log "creating new deployment: $app_name"
    dstack deploy --name "$app_name" --compose docker-compose.production.yml
  fi
  
  success "deployment completed"
}

# Health check with retry logic
health_check() {
  local app_name="$1"
  local max_attempts=60
  local attempt=1
  
  log "performing health check for $app_name..."
  
  while [ $attempt -le $max_attempts ]; do
    log "health check attempt $attempt/$max_attempts"
    
    # Get app status
    status=$(dstack status "$app_name" --format json | jq -r '.status' 2>/dev/null || echo "unknown")
    
    if [ "$status" = "running" ]; then
      # Get endpoint and test
      endpoint=$(dstack status "$app_name" --format json | jq -r '.endpoint' 2>/dev/null)
      
      if [ "$endpoint" != "null" ] && [ -n "$endpoint" ]; then
        if curl -sf "$endpoint/health" > /dev/null; then
          success "health check passed - application is healthy"
          return 0
        fi
      fi
    fi
    
    sleep 10
    ((attempt++))
  done
  
  error "health check failed after $max_attempts attempts"
  return 1
}

# Rollback function
rollback() {
  local app_name="$1"
  local previous_tag="$2"
  
  warning "rolling back $app_name to $previous_tag"
  
  # Update image to previous version
  sed -i "s|image: .*|image: ${IMAGE_NAME}:${previous_tag}|g" docker-compose.production.yml
  
  # Deploy previous version
  dstack update --name "$app_name" --compose docker-compose.production.yml
  
  if health_check "$app_name"; then
    success "rollback completed successfully"
  else
    error "rollback failed"
    exit 1
  fi
}

# Main execution
main() {
  local git_sha=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
  local timestamp=$(date +%Y%m%d%H%M%S)
  local image_tag="${ENVIRONMENT}-${git_sha}-${timestamp}"
  local app_name="${APP_NAME}-${ENVIRONMENT}"
  local previous_tag=$(dstack status "$app_name" --format json | jq -r '.image_tag' 2>/dev/null || echo "")
  
  log "starting CI/CD pipeline for $app_name"
  log "image tag: $image_tag"
  
  # Validate environment
  validate_environment
  
  # Build and test
  build_and_test
  
  # Security scanning
  security_scan
  
  # Docker build and push
  docker_build_and_push "$image_tag"
  
  # Tag as latest for this environment
  docker tag "${IMAGE_NAME}:${image_tag}" "${IMAGE_NAME}:${ENVIRONMENT}-latest"
  docker push "${IMAGE_NAME}:${ENVIRONMENT}-latest"
  
  # Deploy
  deploy_to_dstack "$app_name" "$image_tag"
  
  # Health check with rollback on failure
  if health_check "$app_name"; then
    success "deployment pipeline completed successfully"
    
    # Get final app info
    endpoint=$(dstack status "$app_name" --format json | jq -r '.endpoint')
    log "application available at: $endpoint"
    
    # Save deployment info
    cat > deployment-info.json << EOF
{
  "app_name": "$app_name",
  "image_tag": "$image_tag",
  "endpoint": "$endpoint",
  "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "git_sha": "$git_sha",
  "environment": "$ENVIRONMENT"
}
EOF
    
  else
    error "deployment failed health check"
    if [ -n "$previous_tag" ]; then
      rollback "$app_name" "$previous_tag"
    else
      exit 1
    fi
  fi
}

# Error handling
trap 'error "pipeline failed at line $LINENO"' ERR

# Run main function
main "$@"
```

### Application Monitoring Dashboard Script

```bash
#!/bin/bash
# monitor_app.sh - Real-time Application Monitoring

APP_NAME=${1:-"enterprise-dstack-app-production"}
REFRESH_INTERVAL=${2:-5}

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

clear_screen() {
  clear
  echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${BLUE}‚ïë                       Enterprise dstack Monitor                             ‚ïë${NC}"
  echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
}

get_app_info() {
  dstack status "$APP_NAME" --format json 2>/dev/null || echo "{}"
}

display_status() {
  local app_info=$(get_app_info)
  local status=$(echo "$app_info" | jq -r '.status // "unknown"')
  local endpoint=$(echo "$app_info" | jq -r '.endpoint // "none"')
  local replicas=$(echo "$app_info" | jq -r '.replicas // "1"')
  local created=$(echo "$app_info" | jq -r '.created_at // "unknown"')
  
  echo -e "${YELLOW}Application:${NC} $APP_NAME"
  echo -e "${YELLOW}Status:${NC} $([ "$status" = "running" ] && echo -e "${GREEN}$status${NC}" || echo -e "${RED}$status${NC}")"
  echo -e "${YELLOW}Replicas:${NC} $replicas"
  echo -e "${YELLOW}Endpoint:${NC} $endpoint"
  echo -e "${YELLOW}Created:${NC} $created"
  echo ""
}

check_health() {
  local app_info=$(get_app_info)
  local endpoint=$(echo "$app_info" | jq -r '.endpoint // ""')
  
  if [ -n "$endpoint" ] && [ "$endpoint" != "null" ]; then
    local response_time=$(curl -o /dev/null -s -w "%{time_total}" "$endpoint/health" 2>/dev/null || echo "0")
    local http_code=$(curl -o /dev/null -s -w "%{http_code}" "$endpoint/health" 2>/dev/null || echo "000")
    
    echo -e "${YELLOW}Health Check:${NC}"
    echo "  HTTP Status: $([ "$http_code" = "200" ] && echo -e "${GREEN}$http_code${NC}" || echo -e "${RED}$http_code${NC}")"
    echo "  Response Time: ${response_time}s"
    
    # Check TEE attestation if available
    local attestation_code=$(curl -o /dev/null -s -w "%{http_code}" "$endpoint/attestation" 2>/dev/null || echo "000")
    echo "  TEE Attestation: $([ "$attestation_code" = "200" ] && echo -e "${GREEN}Available${NC}" || echo -e "${YELLOW}Not Available${NC}")"
  else
    echo -e "${YELLOW}Health Check:${NC} ${RED}No endpoint available${NC}"
  fi
  echo ""
}

display_logs() {
  echo -e "${YELLOW}Recent Logs:${NC}"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  dstack logs "$APP_NAME" --tail 15 2>/dev/null | sed 's/^/  /' || echo "  No logs available"
  echo ""
}

display_resources() {
  local stats=$(dstack stats "$APP_NAME" 2>/dev/null || echo "{}")
  
  echo -e "${YELLOW}Resource Usage:${NC}"
  if [ "$stats" != "{}" ]; then
    echo "$stats" | jq -r '. | "  CPU: \(.cpu)%, Memory: \(.memory), Network: \(.network)"' 2>/dev/null || echo "  Stats not available"
  else
    echo "  Resource stats not available"
  fi
  echo ""
}

display_security_info() {
  echo -e "${YELLOW}Security Status:${NC}"
  echo "  TEE Mode: Enabled"
  echo "  Memory Encryption: Active"
  echo "  Remote Attestation: Available"
  echo "  Zero Trust: Enforced"
  echo ""
}

main_loop() {
  while true; do
    clear_screen
    display_status
    check_health
    display_resources
    display_security_info
    display_logs
    
    echo -e "${BLUE}Press Ctrl+C to exit | Refreshing every ${REFRESH_INTERVAL}s${NC}"
    sleep "$REFRESH_INTERVAL"
  done
}

# Error handling
trap 'echo -e "\n${YELLOW}monitoring stopped${NC}"; exit 0' INT TERM

# Validate app exists
if ! dstack status "$APP_NAME" &>/dev/null; then
  echo -e "${RED}Error: Application '$APP_NAME' not found${NC}"
  echo "Available applications:"
  dstack list
  exit 1
fi

# Start monitoring
main_loop
```

### Automated Update and Deployment Script

```bash
#!/bin/bash
# enterprise_update.sh - Enterprise Application Update Automation

set -e

# Configuration
APP_NAME=${APP_NAME:-"enterprise-dstack-app"}
IMAGE_NAME=${IMAGE_REGISTRY:-"your-registry.com"}/${APP_NAME}
COMPOSE_FILE="docker-compose.production.yml"
ENVIRONMENT=${ENVIRONMENT:-"production"}

echo "=========================================="
echo "üîÑ Starting Enterprise Application Update"
echo "=========================================="

# Step 1: Pre-deployment checks
echo "üîç running pre-deployment checks..."
if ! dstack status "${APP_NAME}-${ENVIRONMENT}" &>/dev/null; then
  echo "‚ùå Error: Application not found"
  exit 1
fi

# Step 2: Pull latest code changes
echo "üì• pulling latest code from repository..."
git fetch origin
git checkout main
git pull origin main
if [ $? -ne 0 ]; then
  echo "‚ùå Error: failed to pull latest code"
  exit 1
fi

# Step 3: Install/update dependencies
echo "üì¶ installing dependencies..."
if [ -f "package.json" ]; then
  npm ci --frozen-lockfile
  npm run build
elif [ -f "requirements.txt" ]; then
  pip install -r requirements.txt
elif [ -f "Cargo.toml" ]; then
  cargo build --release
fi

# Step 4: Run comprehensive tests
echo "üß™ running tests..."
if [ -f "package.json" ] && grep -q "test" package.json; then
  npm test
  npm run lint
elif [ -f "pytest.ini" ] || [ -f "tests/" ]; then
  python -m pytest --cov --cov-report=html
elif [ -f "Cargo.toml" ]; then
  cargo test
fi

# Step 5: Security scanning
echo "üîí running security scans..."
if [ -f "package.json" ]; then
  npm audit --audit-level=moderate
elif [ -f "requirements.txt" ]; then
  safety check
fi

# Step 6: Build new Docker image
echo "üê≥ building Docker image..."
GIT_SHA=$(git rev-parse --short HEAD)
TIMESTAMP=$(date +%Y%m%d%H%M%S)
NEW_TAG="${ENVIRONMENT}-${GIT_SHA}-${TIMESTAMP}"

docker build \
  --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
  --build-arg VCS_REF=$GIT_SHA \
  --build-arg VERSION=$NEW_TAG \
  -t $IMAGE_NAME:$NEW_TAG .

if [ $? -ne 0 ]; then
  echo "‚ùå Error: Docker build failed"
  exit 1
fi

# Step 7: Build multi-platform image for compatibility
echo "üèóÔ∏è  building multi-platform image..."
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
  --build-arg VCS_REF=$GIT_SHA \
  --build-arg VERSION=$NEW_TAG \
  -t $IMAGE_NAME:$NEW_TAG \
  --push \
  --provenance=false .

# Step 8: Update Docker Compose configuration
echo "‚öôÔ∏è  updating Docker Compose configuration..."
cp $COMPOSE_FILE "${COMPOSE_FILE}.backup"
sed -i "s|image: .*|image: ${IMAGE_NAME}:${NEW_TAG}|g" $COMPOSE_FILE

# Step 9: Deploy update to dstack
echo "üöÄ deploying update to dstack..."
dstack update \
  --name "${APP_NAME}-${ENVIRONMENT}" \
  --compose $COMPOSE_FILE

# Step 10: Verify deployment with comprehensive health checks
echo "‚úÖ verifying deployment..."
sleep 30  # Wait for deployment to stabilize

# Get application URL
APP_URL=$(dstack status "${APP_NAME}-${ENVIRONMENT}" --format json | jq -r '.endpoint')

if [ "$APP_URL" != "null" ] && [ -n "$APP_URL" ]; then
  echo "üåê testing application endpoint: $APP_URL"
  
  # Test health endpoint
  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL/health)
  
  if [ "$HTTP_STATUS" = "200" ]; then
    # Test TEE attestation
    ATTESTATION_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL/attestation)
    
    echo "‚úÖ application update completed successfully!"
    echo "üîó access your app at: $APP_URL"
    echo "üîí TEE attestation: $([ "$ATTESTATION_STATUS" = "200" ] && echo "Available" || echo "Checking...")"
    
    # Clean up old backup
    rm "${COMPOSE_FILE}.backup"
  else
    echo "‚ö†Ô∏è  application deployed but health check failed (HTTP $HTTP_STATUS)"
    echo "üîÑ rolling back to previous version..."
    
    # Rollback
    mv "${COMPOSE_FILE}.backup" $COMPOSE_FILE
    dstack update \
      --name "${APP_NAME}-${ENVIRONMENT}" \
      --compose $COMPOSE_FILE
    
    echo "check logs: dstack logs ${APP_NAME}-${ENVIRONMENT}"
    exit 1
  fi
else
  echo "‚ö†Ô∏è  could not retrieve application URL"
  echo "check deployment status: dstack status ${APP_NAME}-${ENVIRONMENT}"
  exit 1
fi

echo "=========================================="
echo "üìä deployment Summary"
echo "=========================================="
echo "App Name: ${APP_NAME}-${ENVIRONMENT}"
echo "Image: $IMAGE_NAME:$NEW_TAG"
echo "Compose: $COMPOSE_FILE"
echo "Status: $(dstack status ${APP_NAME}-${ENVIRONMENT} --format json | jq -r '.status')"
echo "URL: $APP_URL"
echo "Git SHA: $GIT_SHA"
echo "=========================================="

# Save deployment record
cat > "deployment-${TIMESTAMP}.json" << EOF
{
  "app_name": "${APP_NAME}-${ENVIRONMENT}",
  "image_tag": "$NEW_TAG",
  "endpoint": "$APP_URL",
  "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "git_sha": "$GIT_SHA",
  "environment": "$ENVIRONMENT"
}
EOF

echo "üìù deployment record saved: deployment-${TIMESTAMP}.json"
```

## Enterprise Configuration Management

### Environment Configuration

```bash
# environments/production.env
NODE_ENV=production
TEE_ENVIRONMENT=dstack
LOG_LEVEL=info
METRICS_ENABLED=true
TRACING_ENABLED=true
SECURITY_HEADERS=true
CORS_ORIGIN=https://your-domain.com
DATABASE_SSL=require
REDIS_TLS=true
```

### Secrets Management

```bash
# scripts/setup-secrets.sh
#!/bin/bash

# Create production secrets
dstack secret create production-secrets \
  --from-literal=database_password=$(openssl rand -hex 32) \
  --from-literal=jwt_secret=$(openssl rand -hex 64) \
  --from-literal=encryption_key=$(openssl rand -hex 32) \
  --from-literal=api_key=$(openssl rand -hex 16)

# TLS certificates
dstack secret create tls-certs \
  --from-file=tls.crt=./certs/server.crt \
  --from-file=tls.key=./certs/server.key
```

## Monitoring and Observability

### Metrics Collection

```yaml
# monitoring/prometheus.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  grafana_data:
```

### Log Aggregation

```yaml
# logging/fluentd.conf
<source>
  @type forward
  port 24224
  bind 0.0.0.0
</source>

<match dstack.**>
  @type elasticsearch
  host elasticsearch
  port 9200
  index_name dstack-logs
  type_name _doc
</match>
```

## Security Best Practices

### Network Security

```bash
# scripts/setup-network-security.sh
#!/bin/bash

# Configure firewall rules
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw allow 443/tcp
ufw allow 80/tcp
ufw enable

# Setup fail2ban
apt-get install fail2ban
systemctl enable fail2ban
systemctl start fail2ban
```

### Access Control

```yaml
# rbac/dstack-rbac.yml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: dstack-deployer
  namespace: production

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: dstack-deployer
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
```

## Disaster Recovery

### Backup Strategy

```bash
# scripts/backup.sh
#!/bin/bash

BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/dstack-${BACKUP_DATE}"

mkdir -p $BACKUP_DIR

# Backup database
pg_dump $DATABASE_URL > "${BACKUP_DIR}/database.sql"

# Backup configurations
cp -r ./configs "${BACKUP_DIR}/"

# Backup secrets
dstack secret export --all > "${BACKUP_DIR}/secrets.yaml"

# Upload to cloud storage
aws s3 sync $BACKUP_DIR s3://your-backup-bucket/dstack-backups/
```

### Recovery Procedures

```bash
# scripts/restore.sh
#!/bin/bash

BACKUP_DATE=$1
BACKUP_DIR="/backups/dstack-${BACKUP_DATE}"

if [ ! -d "$BACKUP_DIR" ]; then
  echo "backup directory not found: $BACKUP_DIR"
  exit 1
fi

# Restore database
psql $DATABASE_URL < "${BACKUP_DIR}/database.sql"

# Restore configurations
cp -r "${BACKUP_DIR}/configs" ./

# Restore secrets
dstack secret import "${BACKUP_DIR}/secrets.yaml"

echo "restore completed from backup: $BACKUP_DATE"
```

## What's Next?

Your enterprise dstack deployment now includes:

‚úÖ **CI/CD Automation** - Fully automated deployment pipeline
‚úÖ **Monitoring & Observability** - Comprehensive monitoring setup
‚úÖ **Security Best Practices** - Enterprise-grade security configuration
‚úÖ **Disaster Recovery** - Backup and recovery procedures
‚úÖ **Scalability** - Production-ready scaling patterns

### Continue Learning

- [Advanced dstack Features](/docs/concepts/overview)
- [Security Model](/docs/concepts/security-model)
- [Python Tutorial](/docs/tutorials/python-example)
- [JavaScript Tutorial](/docs/tutorials/javascript-example)
- [Rust Tutorial](/docs/tutorials/rust-example) 