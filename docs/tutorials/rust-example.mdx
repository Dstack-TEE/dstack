---
title: "Super Quick Start - Rust Tutorial"
description: "Deploy a Rust application to dstack TEE infrastructure"
---

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">

  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
    <h2 className="font-semibold text-blue-900 mb-2">What You'll Build</h2>
    <p className="mb-2">A secure, high-performance Actix-web API that demonstrates:</p>
    <ul className="list-disc list-inside text-sm text-blue-900 space-y-1">
      <li>High-performance secure endpoints</li>
      <li>Hardware-accelerated cryptography</li>
      <li>TEE attestation verification</li>
      <li>Zero-overhead security</li>
    </ul>
    <p className="mt-4 text-xs text-blue-700">
      This tutorial walks you through deploying a Rust application to dstack's Trusted Execution Environment infrastructure. Perfect for security-critical and high-performance workloads.
    </p>
  </div>

  <div className="bg-green-50 border border-green-200 rounded-lg p-4">
    <h2 className="font-semibold text-green-900 mb-2">Prerequisites</h2>
    <ul className="list-disc list-inside text-sm text-green-900 space-y-1">
      <li>Rust toolchain installed (<code>rustc</code>, <code>cargo</code>)</li>
      <li>Docker installed for containerization</li>
      <li>Basic command line knowledge</li>
      <li>A container registry account (Docker Hub, GitHub Container Registry, etc.)</li>
    </ul>
  </div>

</div>

## Step 1: Create Your Application

### Project Setup

Create a new Rust project:

```bash
cargo new secure-rust-app
cd secure-rust-app
```

### Update Cargo.toml

```toml
[package]
name = "secure-rust-app"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
```

### Application Code

Create `src/main.rs`:

```rust
use actix_web::{web, App, HttpResponse, HttpServer, Result, middleware::Logger};
use serde::{Deserialize, Serialize};
use chrono::Utc;

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    message: String,
    secure: bool,
    environment: String,
    timestamp: String,
    tee_enabled: bool,
}

#[derive(Serialize)]
struct ComputeResponse {
    processed: bool,
    secure_computation: String,
    result: String,
    tee_protected: bool,
    performance: String,
}

#[derive(Deserialize)]
struct ComputeRequest {
    data: String,
}

async fn health() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(HealthResponse {
        status: "healthy".to_string(),
        message: "TEE Rust application running".to_string(),
        secure: true,
        environment: "dstack-tee".to_string(),
        timestamp: Utc::now().to_rfc3339(),
        tee_enabled: true,
    }))
}

async fn compute(req: web::Json<ComputeRequest>) -> Result<HttpResponse> {
    // Simulate secure high-performance computation
    let start = std::time::Instant::now();
    
    // Your secure computation logic here
    let processed_data = format!("Securely processed: {}", req.data);
    
    let duration = start.elapsed();
    
    Ok(HttpResponse::Ok().json(ComputeResponse {
        processed: true,
        secure_computation: "completed".to_string(),
        result: processed_data,
        tee_protected: true,
        performance: format!("{}μs", duration.as_micros()),
    }))
}

async fn attestation() -> Result<HttpResponse> {
    // In a real implementation, this would return actual TEE attestation
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "attestation_available": true,
        "tee_type": "Intel TDX",
        "security_level": "hardware_enforced",
        "quote_available": true
    })))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init();

    println!("Starting TEE Rust application on port 8080");

    HttpServer::new(|| {
        App::new()
            .wrap(Logger::default())
            .route("/", web::get().to(health))
            .route("/health", web::get().to(health))
            .route("/api/compute", web::post().to(compute))
            .route("/attestation", web::get().to(attestation))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
```

### Add Logging Dependencies

Update `Cargo.toml`:

```toml
[dependencies]
actix-web = "4.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
env_logger = "0.10"
```

## Step 2: Containerize for dstack

### Create Dockerfile

```dockerfile
# Multi-stage build for optimized production image
FROM rust:1.75 as builder

WORKDIR /app

# Copy manifest files
COPY Cargo.toml Cargo.lock ./

# Copy source code
COPY src ./src

# Build application with optimizations
RUN cargo build --release

# Production stage
FROM debian:bookworm-slim

# Install required system packages
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -r -s /bin/false dstack

# Copy binary from builder stage
COPY --from=builder /app/target/release/secure-rust-app /usr/local/bin/tee-app

# Set ownership
RUN chown dstack:dstack /usr/local/bin/tee-app

# Switch to non-root user
USER dstack

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Run application
CMD ["tee-app"]
```

### Create Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info
      - TEE_ENVIRONMENT=dstack
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 4G
        reservations:
          cpus: '2'
          memory: 2G
```

## Step 3: Deploy to dstack

### Build and Test Locally

```bash
# Build the application
cargo build --release

# Test locally
cargo run &
curl http://localhost:8080/health
```

### Build and Push Container

```bash
# Build the Docker image
docker build -t your-registry/rust-tee-app:latest .

# Test the container
docker run -p 8080:8080 your-registry/rust-tee-app:latest &
curl http://localhost:8080/health

# Push to your container registry
docker push your-registry/rust-tee-app:latest
```

### Deploy to dstack Infrastructure

For quick testing with a cloud partner (recommended):

```bash
# Example using a dstack-compatible cloud provider
# Note: This example uses a third-party service to demonstrate dstack capabilities

# Authenticate with your chosen cloud provider
cloud-cli auth login YOUR_API_TOKEN

# Deploy your container to TEE infrastructure
cloud-cli deploy create \
  --name rust-tee-app \
  --image your-registry/rust-tee-app:latest \
  --port 8080 \
  --tee-enabled \
  --cpu 4 \
  --memory 4G

# Check deployment status
cloud-cli deploy status rust-tee-app
```

### For Self-Hosted dstack

If you have your own dstack infrastructure:

```bash
# Deploy using dstack CLI
dstack deploy \
  --name rust-tee-app \
  --compose docker-compose.yml \
  --tee-enabled

# Monitor deployment
dstack status rust-tee-app
```

## Step 4: Test Your Deployment

### Verify Application Performance

```bash
# Get your application URL
APP_URL=$(cloud-cli deploy describe rust-tee-app --format json | jq -r '.endpoint')

# Test health endpoint
curl $APP_URL/health

# Test secure computation with performance metrics
curl -X POST $APP_URL/api/compute \
  -H "Content-Type: application/json" \
  -d '{"data": "high-performance secure computation"}' | jq
```

### Performance Benchmarking

```bash
# Install Apache Bench for load testing
sudo apt-get install apache2-utils

# Benchmark the secure endpoint
ab -n 1000 -c 10 $APP_URL/health

# Test concurrent secure computations
ab -n 100 -c 5 -p payload.json -T application/json $APP_URL/api/compute
```

Create `payload.json`:
```json
{"data": "benchmark test data"}
```

### Verify TEE Security

```bash
# Check TEE attestation
curl $APP_URL/attestation | jq

# Verify secure environment
curl $APP_URL/ | jq '.secure'
```

## Step 5: Application Management

### Update Script

Create `update.sh`:

```bash
#!/bin/bash
set -e

APP_NAME="rust-tee-app"
IMAGE_NAME="your-registry/rust-tee-app"

echo "updating Rust application..."

# Pull latest code
git pull origin main

# Run tests
cargo test

# Build optimized release
cargo build --release

# Build and push new image
docker build -t $IMAGE_NAME:latest .
docker push $IMAGE_NAME:latest

# Update deployment
cloud-cli deploy update \
  --name $APP_NAME \
  --image $IMAGE_NAME:latest

echo "Rust application updated successfully!"
```

### Monitoring Commands

```bash
# View logs
cloud-cli deploy logs rust-tee-app --follow

# Check resource usage and performance
cloud-cli deploy stats rust-tee-app

# Scale for high performance workloads
cloud-cli deploy scale rust-tee-app --cpu 8 --memory 8G
```

### Performance Optimization

Add to `Cargo.toml` for maximum performance:

```toml
[profile.release]
lto = true
codegen-units = 1
panic = "abort"
```

## What's Next?

Your Rust application is now running in a hardware-secured TEE environment with:

✅ **Zero-overhead security** - Hardware protection without performance cost
✅ **High-performance computation** - Optimized Rust code in secure environment
✅ **Memory safety** - Rust's memory safety + hardware memory encryption
✅ **Attestation support** - Cryptographic proof of security

### Continue Learning

- [Advanced dstack Features](/docs/concepts/overview)
- [Security Model](/docs/concepts/security-model)
- [Production Deployment](/docs/deployment-guides/deploying-applications)
- [Python Tutorial](/docs/tutorials/python-example)
- [JavaScript Tutorial](/docs/tutorials/javascript-example) 